import React from 'react';
import ReactDOM from 'react-dom';
import ReactDOMServer from 'react-dom/server';

/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
/* global Reflect, Promise */

var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return extendStatics(d, b);
};

function __extends(d, b) {
    extendStatics(d, b);
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}

var __assign = function() {
    __assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};

/**
 * map for script names against utility objects
 */
var loadedScripts = new Map();
/**
 * script tags to be generated by the cache method
 */
var scriptTags = {};
/**
 *
 * @param scripts {Scripts} - An object with all the scripts required.
 * Keys are script names, values are URLs.
 */
function cache(scripts) {
    Object.entries(scripts).forEach(function (_a) {
        var script = _a[0], name = _a[1];
        var _b;
        var tag = getScript(script, name);
        if (tag) {
            scriptTags = __assign({}, scriptTags, (_b = {}, _b[name] = {
                name: name,
                onLoad: onLoad.bind(null, name),
                script: script,
                tag: tag,
            }, _b));
        }
    });
}
/**
 * Callback to be fired when each script has loaded.
 * @param name {string} - The name of the string that has just loaded.
 * @param callback {Callback} - A callback to execute when the script has loaded.
 */
function onLoad(name, callback) {
    var stored = loadedScripts.get(name);
    if (stored && stored.hasLoaded) {
        callback(null, stored);
    }
    else if (stored) {
        stored.promise.then(function () {
            stored.wasRejected ? callback(stored.error) : callback(null, stored);
        });
    }
}
/**
 * Callback to be fired when all scripts have loaded
 * @param callback {Function} - The callback to be executed.
 */
function onAllLoad(callback) {
    var promises = [];
    var results = [];
    loadedScripts.forEach(function (value) {
        if (value.hasLoaded) {
            results.push(value);
        }
        else {
            promises.push(value.promise);
        }
    });
    if (promises.length > 0) {
        Promise.all(promises)
            .then(function (res) { return callback(undefined, res); })
            .catch(function (errs) { return callback(errs, undefined); });
    }
    else {
        callback(undefined, results);
    }
}
/**
 * Get a script from a remote location.
 * @param name {string} - The name of the script to be retrieved.
 * @param url {string} - The URL/location of the script to be retrieved.
 */
function getScript(url, name) {
    if (!loadedScripts.has(name) &&
        !document.querySelector("script[src=\"" + url + "\"]")) {
        var tag_1 = document.createElement('script');
        var promise = new Promise(function (resolve, reject) {
            var body = document.getElementsByTagName('body')[0];
            // make sure the script type is javascript
            // and that scripts are loaded in order using
            // the "async" option
            tag_1 = __assign({}, tag_1, { async: false, type: 'text/javascript' });
            function handleResult(event) {
                var stored = loadedScripts.get(name);
                if (stored) {
                    if (event.type === 'load') {
                        stored.hasLoaded = true;
                        resolve(stored);
                    }
                    else if (event.type === 'error') {
                        stored.wasRejected = true;
                        reject(stored.error);
                    }
                }
                else {
                    reject('Script does not exist');
                }
            }
            // add load and error event listeners
            tag_1.addEventListener('load', handleResult);
            tag_1.addEventListener('error', handleResult);
            tag_1 = __assign({}, tag_1, { src: url });
            body.appendChild(tag_1);
        });
        var scriptObject = {
            hasLoaded: false,
            promise: promise,
            tag: tag_1,
            wasRejected: false,
        };
        loadedScripts.set(name, scriptObject);
    }
    return loadedScripts.get(name);
}

// /**
//  * Returns a function, that, as long as it continues to be invoked, will not
//  * be triggered. The function will be called after it stops being called for
//  * N milliseconds. If `immediate` is passed, trigger the function on the
//  * leading edge, instead of the trailing. The function also has a property 'clear'
//  * that is a function which will clear the timer to prevent previously scheduled executions.
//  *
//  * @source underscore.js
//  * @see http://unscriptable.com/2009/03/20/debouncing-javascript-methods/
//  * @param {Function} function to wrap
//  * @param {Number} timeout in ms (`100`)
//  * @param {Boolean} whether to execute at the beginning (`false`)
//  * @api public
//  */
// function debounce(func: () => void, wait: number, immediate: boolean) {
//   let timeout: NodeJS.Timeout | null
//   let args: [] | null
//   let context
//   let timestamp
//   let result
//   if (null == wait) wait = 100
//   function later() {
//     let last = Date.now() - timestamp
//     if (last < wait && last >= 0) {
//       timeout = setTimeout(later, wait - last)
//     } else {
//       timeout = null
//       if (!immediate) {
//         result = func.apply(context, args)
//         context = args = null
//       }
//     }
//   }
//   const debounced = (...args) => {
//     context = this
//     timestamp = Date.now()
//     var callNow = immediate && !timeout
//     if (!timeout) timeout = setTimeout(later, wait)
//     if (callNow) {
//       result = func.apply(context, args)
//       context = args = null
//     }
//     return result
//   }
//   debounced.clear = function() {
//     if (timeout) {
//       clearTimeout(timeout)
//       timeout = null
//     }
//   }
//   debounced.flush = function() {
//     if (timeout) {
//       result = func.apply(context, args)
//       context = args = null
//       clearTimeout(timeout)
//       timeout = null
//     }
//   }
//   return debounced
// }
// export default debounce
function debounce(func, delay, immediate) {
    var timeout;
    if (typeof func !== 'function') {
        throw new TypeError('Expected a function');
    }
    return function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        var callNow = immediate && !timeout;
        if (!delay && delay !== 0) {
            func.apply(void 0, args);
        }
        else {
            if (timeout) {
                clearTimeout(timeout);
            }
            timeout = setTimeout(function () {
                timeout = null;
                if (!immediate) {
                    func.apply(void 0, args);
                }
            }, delay);
            if (callNow) {
                func.apply(void 0, args);
            }
        }
    };
}

/**
 * map for link names against utility objects
 */
var loadedLinks = new Map();
/**
 * Get a style or other linked resource from a remote location.
 * @param url {string} - The URL/location of the resource to be retrieved.
 * @param name {string} - The name of the resource to be retrieved.
 */
function getLink(url, name) {
    if (!loadedLinks.has(name) &&
        !document.querySelector("link[href=\"" + url + "\"]")) {
        var link = document.createElement('link');
        var body = document.getElementsByTagName('body')[0];
        link.href = url;
        link.rel = 'stylesheet';
        link.type = 'text/css';
        body.appendChild(link);
        var linkObject = {
            hasLoaded: false,
            link: link,
            wasRejected: false,
        };
        loadedLinks.set(name, linkObject);
    }
    return loadedLinks.get(name);
}

function getScriptMap(secure) {
    // store the versions of the HERE API
    var apiVersion = 'v3';
    var codeVersion = '3.0';
    // get the relevant protocol for the HERE Maps API
    var protocol = '';
    if (secure === true) {
        protocol = 'https:';
    }
    // the base url for all scripts from the API
    var baseUrl = protocol + "//js.api.here.com/" + (apiVersion + "/" + codeVersion);
    // core code
    var coreScript = baseUrl + "/mapsjs-core.js";
    // service code
    var serviceScript = baseUrl + "/mapsjs-service.js";
    // default ui code
    var uiScript = baseUrl + "/mapsjs-ui.js";
    // map events (pan, scroll wheel zoom) code
    var mapEventsScript = baseUrl + "/mapsjs-mapevents.js";
    // return an array with all script names within
    return {
        coreScript: coreScript,
        mapEventsScript: mapEventsScript,
        serviceScript: serviceScript,
        uiScript: uiScript,
    };
}

var MapContext = React.createContext({});

var platform;
// return the current platform if there is one,
// otherwise open up a new platform
function getPlatform(platformOptions) {
    if (platform) {
        return platform;
    }
    platform = new H.service.Platform(platformOptions);
    return platform;
}

var HEREMap = /** @class */ (function (_super) {
    __extends(HEREMap, _super);
    // public static contextType = MapContext
    function HEREMap(props) {
        var _this = _super.call(this, props) || this;
        _this.createMap = function () {
            var _a = _this.props, appId = _a.appId, appCode = _a.appCode, center = _a.center, hidpi = _a.hidpi, interactive = _a.interactive, zoom = _a.zoom, secure = _a.secure, setLayer = _a.setLayer;
            var platform = getPlatform({
                app_code: appCode,
                app_id: appId,
                useHTTPS: secure === true,
            });
            var defaultLayers = platform.createDefaultLayers({
                ppi: hidpi ? 320 : 72,
            });
            var mapElement = document.querySelector('.map-container');
            var HERE = {};
            var layer = defaultLayers.normal.map;
            if (setLayer) {
                layer = defaultLayers[setLayer.mapType][setLayer.layer];
            }
            if (mapElement) {
                HERE.map = new H.Map(mapElement, layer, {
                    center: center,
                    pixelRatio: hidpi ? 2 : 1,
                    zoom: zoom,
                });
                if (interactive) {
                    HERE.behavior = new H.mapevents.Behavior(new H.mapevents.MapEvents(HERE.map));
                    HERE.ui = H.ui.UI.createDefault(HERE.map, defaultLayers);
                }
            }
            return HERE;
        };
        _this.resizeMap = function () {
            var map = _this.state.map;
            if (map) {
                map.getViewPort().resize();
            }
        };
        _this.state = {
            map: undefined,
            behavior: undefined,
            ui: undefined,
        };
        _this.debouncedResizeMap = debounce(_this.resizeMap, 200);
        return _this;
    }
    HEREMap.prototype.componentDidMount = function () {
        var _this = this;
        var secure = this.props.secure;
        cache(getScriptMap(secure === true));
        var stylesheetUrl = (secure === true ? 'https:' : '') + "//js.api.here.com/v3/3.0/mapsjs-ui.css";
        getLink(stylesheetUrl, 'HERE Maps UI');
        onAllLoad(function () {
            var map = _this.createMap();
            window.addEventListener('resize', _this.debouncedResizeMap);
            _this.setState(__assign({}, map));
        });
    };
    HEREMap.prototype.componentDidUpdate = function (prevProps) {
        if (prevProps.center &&
            this.props.center &&
            (prevProps.center.lat !== this.props.center.lat ||
                prevProps.center.lng !== this.props.center.lng)) {
            this.setCenter(this.props.center);
        }
        if (prevProps.zoom &&
            this.props.zoom &&
            prevProps.zoom !== this.props.zoom) {
            this.setZoom(this.props.zoom);
        }
    };
    HEREMap.prototype.componentWillUnmount = function () {
        window.removeEventListener('resize', this.debouncedResizeMap);
    };
    HEREMap.prototype.getElement = function () {
        return ReactDOM.findDOMNode(this);
    };
    HEREMap.prototype.setCenter = function (point) {
        var animateCenter = this.props.animateCenter;
        var map = this.state.map;
        if (map) {
            map.setCenter(point, animateCenter === true);
        }
    };
    HEREMap.prototype.setZoom = function (zoom) {
        var animateZoom = this.props.animateZoom;
        var map = this.state.map;
        if (map) {
            map.setZoom(zoom, animateZoom === true);
        }
    };
    HEREMap.prototype.render = function () {
        var map = this.state.map;
        var children = this.props.children;
        return (React.createElement(MapContext.Provider, { value: this.state },
            React.createElement("div", { className: "map-container", id: "map-container", style: { height: '100%' } }, map ? children : null)));
    };
    return HEREMap;
}(React.Component));

var Circle = /** @class */ (function (_super) {
    __extends(Circle, _super);
    function Circle() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Circle.prototype.componentDidUpdate = function (prevProps) {
        if (prevProps.lat !== this.props.lat || prevProps.lng !== this.props.lng) {
            this.setCenter({
                lat: prevProps.lat,
                lng: prevProps.lng,
            });
        }
        if (prevProps.radius && prevProps.radius !== this.props.radius) {
            this.setRadius(prevProps.radius);
        }
    };
    Circle.prototype.componentWillUnmount = function () {
        var map = this.context.map;
        if (map && this.circle) {
            map.removeObject(this.circle);
        }
    };
    Circle.prototype.addCircleToMap = function () {
        var map = this.context.map;
        var _a = this.props, lat = _a.lat, lng = _a.lng, strokeColor = _a.strokeColor, lineWidth = _a.lineWidth, fillColor = _a.fillColor, radius = _a.radius;
        var circle = new H.map.Circle({
            lat: lat,
            lng: lng,
        }, radius, {
            style: {
                fillColor: fillColor,
                lineWidth: lineWidth,
                strokeColor: strokeColor,
            },
        });
        if (map) {
            map.addObject(circle);
            this.circle = circle;
        }
    };
    Circle.prototype.setCenter = function (point) {
        if (this.circle) {
            this.circle.setCenter(point);
        }
    };
    Circle.prototype.setRadius = function (radius) {
        if (this.circle) {
            this.circle.setRadius(radius);
        }
    };
    Circle.prototype.render = function () {
        var map = this.context.map;
        if (map && !this.circle) {
            this.addCircleToMap();
        }
        return null;
    };
    Circle.contextType = MapContext;
    Circle.defaultProps = {
        fillColor: 'rgba(255, 255, 255, 0.5)',
        lineWidth: 1,
        radius: 1000,
        strokeColor: 'black',
    };
    return Circle;
}(React.Component));

/**
 * Map for HTML strings against H.map.DomIcon instances
 */
var DomIcons = new Map();
/**
 * Returns the DOM Icon for the input HTML string, ensuring that no more
 * than one DOM Icon is created for each HTML string
 * @param html {string} - A string containing the markup to be used as a Dom Icon.
 */
function getDomMarkerIcon(html) {
    if (!DomIcons.has(html)) {
        var icon = new H.map.DomIcon(html);
        DomIcons.set(html, icon);
    }
    return DomIcons.get(html);
}

/**
 * Map for image URL strings against H.map.Icon instances
 */
var Icons = new Map();
/**
 * Returns the Icon for the input bitmap URL string, ensuring that no more
 * than one Icon is created for each bitmap
 * @param bitmap {string} - The location of the bitmap to be used as an icon
 */
function getMarkerIcon(bitmap) {
    if (!Icons.has(bitmap)) {
        var icon = new H.map.Icon(bitmap);
        Icons.set(bitmap, icon);
    }
    return Icons.get(bitmap);
}

/**
 * A helper function that disables map behavior on drag event in order to allow
 * the marker to be moved.
 * @param map
 * @param behavior
 */
function setMarkerDragEvent(map, behavior) {
    map.addEventListener('dragstart', function (e) {
        if (e.target instanceof H.map.Marker ||
            e.target instanceof H.map.DomMarker) {
            behavior.disable();
        }
    }, false);
    map.addEventListener('dragend', function (e) {
        if (e.target instanceof H.map.Marker ||
            e.target instanceof H.map.DomMarker) {
            behavior.enable();
        }
    }, false);
    map.addEventListener('drag', function (e) {
        var target = e.target;
        var pointer = e.currentPointer;
        if (target instanceof H.map.Marker ||
            e.target instanceof H.map.DomMarker) {
            target.setPosition(map.screenToGeo(pointer.viewportX, pointer.viewportY));
        }
    }, false);
}

var markerEvents = {
    onDragStart: 'dragstart',
    onDrag: 'drag',
    onDragEnd: 'dragend',
};
var Marker = /** @class */ (function (_super) {
    __extends(Marker, _super);
    function Marker() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Marker.prototype.componentDidMount = function () {
        var _this = this;
        var map = this.context.map;
        if (map && !this.marker) {
            this.addMarkerToMap();
        }
        if (this.marker) {
            Object.entries(markerEvents).forEach(function (_a) {
                var event = _a[0], hereEvent = _a[1];
                if (typeof _this.props[event] === 'function') {
                    _this.marker.addEventListener(hereEvent, _this.props[event]);
                }
            });
        }
    };
    Marker.prototype.componentDidUpdate = function (prevProps) {
        if (prevProps.lat !== this.props.lat || prevProps.lng !== this.props.lng) {
            this.setPosition({
                lat: this.props.lat,
                lng: this.props.lng,
            });
        }
    };
    Marker.prototype.componentWillUnmount = function () {
        var _this = this;
        var map = this.context.map;
        if (this.marker) {
            Object.entries(markerEvents).forEach(function (_a) {
                var event = _a[0], hereEvent = _a[1];
                if (typeof _this.props[event] === 'function') {
                    _this.marker.removeEventListener(hereEvent, _this.props[event]);
                }
            });
        }
        if (map && this.marker) {
            map.removeObject(this.marker);
        }
    };
    Marker.prototype.addMarkerToMap = function () {
        var _a = this.context, map = _a.map, behavior = _a.behavior;
        var _b = this.props, children = _b.children, bitmap = _b.bitmap, lat = _b.lat, lng = _b.lng, draggable = _b.draggable;
        var marker;
        if (map) {
            if (React.Children.count(children) > 0) {
                var html = ReactDOMServer.renderToStaticMarkup(React.createElement("div", { className: "dom-marker" }, children));
                var icon = getDomMarkerIcon(html);
                marker = new H.map.DomMarker({ lat: lat, lng: lng }, { icon: icon });
            }
            else if (bitmap) {
                var icon = getMarkerIcon(bitmap);
                marker = new H.map.Marker({ lat: lat, lng: lng }, { icon: icon });
            }
            else {
                marker = new H.map.Marker({ lat: lat, lng: lng });
            }
            if (draggable && behavior) {
                marker.draggable = draggable;
                setMarkerDragEvent(map, behavior);
            }
            map.addObject(marker);
            this.marker = marker;
        }
        return null;
    };
    Marker.prototype.setPosition = function (point) {
        if (this.marker) {
            this.marker.setPosition(point);
        }
    };
    Marker.prototype.render = function () {
        return null;
    };
    Marker.contextType = MapContext;
    return Marker;
}(React.Component));

var RouteLine = /** @class */ (function (_super) {
    __extends(RouteLine, _super);
    function RouteLine() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.didShapeChange = function (prevShape, nextShape) {
            var diff = nextShape.filter(function (coord, i) {
                if (coord && prevShape && prevShape[i]) {
                    return coord !== prevShape[i];
                }
                return true;
            });
            return Boolean(diff.length);
        };
        return _this;
    }
    RouteLine.prototype.componentDidUpdate = function (prevProps) {
        var shape = this.props.shape;
        if (this.didShapeChange(prevProps.shape, shape)) {
            this.addRouteLineToMap();
        }
    };
    RouteLine.prototype.componentWillUnmount = function () {
        var map = this.context.map;
        if (map && this.routeLine) {
            map.removeObject(this.routeLine);
        }
    };
    RouteLine.prototype.addRouteLineToMap = function () {
        var map = this.context.map;
        var _a = this.props, shape = _a.shape, strokeColor = _a.strokeColor, lineWidth = _a.lineWidth;
        var linestring = new H.geo.LineString();
        shape.forEach(function (point) {
            var _a = point.split(','), lat = _a[0], lng = _a[1];
            linestring.pushLatLngAlt(Number(lat), Number(lng), 1);
        });
        var routeLine = new H.map.Polyline(linestring, {
            style: { strokeColor: strokeColor, lineWidth: lineWidth },
        });
        if (map) {
            if (this.routeLine) {
                map.removeObject(this.routeLine);
            }
            map.addObject(routeLine);
            this.routeLine = routeLine;
        }
    };
    RouteLine.prototype.render = function () {
        var map = this.context.map;
        if (map && !this.routeLine) {
            this.addRouteLineToMap();
        }
        return null;
    };
    RouteLine.contextType = MapContext;
    return RouteLine;
}(React.Component));

export default HEREMap;
export { Circle, HEREMap, Marker, RouteLine };
//# sourceMappingURL=index.es.js.map
